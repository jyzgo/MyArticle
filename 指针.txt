某小盆友问我this指针是什么意思，遥想起我当年学这个的时候也是对这个简单的概念理解的比较费劲，加上一言两语又说不明白，所以就决定写这个文儿。


从一条语句开始
ClassA* A = new ClassA();

我们的内存条中有两块区域，一块叫堆，一块叫栈，因为数据结构的原因，堆的速度要比栈的速度慢很多。而且只能由程序员自己管理空间分配和销毁。
但堆的优势就是容量大。



所以 当我们写

int num = 10 ;

这个num就是存在栈里的，无需我们自己管理，会被自己释放掉



所以我们来看看这句话

ClassA* A = new ClassA();

那这个A这个值是写在哪儿的呢？

正确答案是：还是写在栈上的

这块很令人费解 ，如果
int i = 10;
i是写在栈上的
那
ClassA* A = new ClassA();
明显不应该写在栈上，而应该存在普通内存上的啊！因为书上明摆着写这 “分配动态内存”啊！

这里就得希望大家发挥想象力了，
想象一下你坐在一个桌子边，桌子上有一个小盒子（栈），你随手就可以拿到，你的身后有一个巨大的仓库（堆区），仓库里面有很多的货架，每个货架都有自己的编号方便你去查找，
现在你写下：
int i = 10;
你拿到一张纸条，上面写 
	“一个叫i的int，值为10”,然后放到你桌子上的小盒子里。
现在你又写下了：
ClassA* A = new ClassA();
然后你又拿了一张纸条，上面写 
	“一个叫A的ClassA，放在仓库里第3个货架第二个格子里”
然后你把这张纸条也放到桌子上的小盒子里，
但是！编译器会根据这条指令，在第3个货架第二个格子里创造一个ClassA
要注意！这个“第3个货架第二个格子”不是你自己设定的，是编译器自动分配的，这就是所谓的“分配动态内存”

所以当你取用 i 的时候，你是直接随手从盒子里取出i的那张纸条，一看 值是10.
而当你要取用 A 的时候，你从盒子里取出A的那张纸条，然后跑到仓库里，对应的位置（第3个货架，第二个格子）翻出那个ClassA （好大的一个箱子）

这就是我们所谓的“指针”的含义，指针指向“内存地址”的具体意思。

然后我们再看另一个例子
ClassA* A = new ClassA();
		A = new ClassA();

这两句语句造成了我们所谓的“内存泄露”，自己思考一下吧。

有了这个概念，我们再看一下this指针的概念。
this指针，代表的是类自己，我们设计这么一个类

class ClassA
{
public:
	void func1();

	void func2();

	int m_num;

};

void ClassA::func1()
{
	this->func2();
}

void ClassA::setNum(num)
{
	m_num = num;
}

void ClassA::func2()
{
	int curNum = this->m_num;
	printf("%d\n", curNum);
}

所以在我们如下使用方法的时候

void int main(int argc, char const *argv[])
{
	ClassA* A = new ClassA();
	A->setNum(10);
	A->func1();

	ClassA* B = new ClassA();
	B->setNum(20);
	B->func1();
}

func1会调用各自不同的func2，然后调用各自的m_num,

想象一下，我们在仓库里创建了两个ClassA的货柜，然后每个货柜里都有 func1，func2和 m_num三个成员，然后他们之间会互相调用，
so，就是这样



