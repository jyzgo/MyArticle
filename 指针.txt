某小盆友问我this指针是什么意思，遥想起我当年学这个的时候也是对这个简单的概念理解的比较费劲，加上一言两语又说不明白，所以就决定写这个文儿。


从一条语句开始
ClassA* A = new ClassA();

书上都讲这个语句的意思是分配内存地址给ClassA，但很少有书涉及底层的事情，这里就从计算机的结构讲起

我们自己攒电脑，选择CPU的时候经常会看到这么一个参数 , L1 Cache / L2 Cache 
翻译过来是1级缓存和2级缓存，我们就叫他CPU缓存吧，CPU进行数据处理的时候，会在这里进行临时的数据存储。
这东西的主要特点是:1.速度极快 2.容量很小 3.价格极贵
所以 虽然它的速度要比普通的内存条要快上好几个数量级，但是它的容量依然很小，现在可能也就1~2M，酷睿i7的3级缓存也就8M，相对于普通内存条动不动8G 16G的容量，CPU的缓存实在太小了

所以这就决定了它只能放一些关键性的数据，而不会把全部的东西存在这儿。

所以 当我们写

int num = 10 ;

这个num就是存在CPU缓存里的，无需我们自己管理，会被自己释放掉

讲完缓存，讲一下普通的内存条，也就是攒机器的时候买的内存条，100多块钱 4G一条的那种
这种存储器速度很慢（相对Cache而言），但容量很大，白菜价，所以可以用来保存不那么重要的大容量的数据

所以我们来看看这句话

ClassA* A = new ClassA();

那这个A这个值是写在哪儿的呢？

正确答案是：还是写在缓存上的

这块很令人费解 ，如果
int i = 10;
i是写在缓存上的
那
ClassA* A = new ClassA();
明显不应该写在缓存上，而应该存在普通内存上的啊！因为书上明摆着写这 “分配动态内存”啊！

这里就得希望大家发挥想象力了，
想象一下你坐在一个桌子边，桌子上有一个小盒子（CPU缓存），你随手就可以拿到，你的身后有一个巨大的仓库（普通内存），仓库里面有很多的货架，每个货架都有自己的编号方便你去查找，
现在你写下：
int i = 10;
你拿到一张纸条，上面写 
	“一个叫i的int，值为10”,然后放到你桌子上的小盒子里。
现在你又写下了：
ClassA* A = new ClassA();
然后你又拿了一张纸条，上面写 
	“一个叫A的ClassA，放在仓库里第3个货架第二个格子里”
然后你把这张纸条也放到桌子上的小盒子里，
但是！编译器会根据这条指令，在第3个货架第二个格子里创造一个ClassA
要注意！这个“第3个货架第二个格子”不是你自己设定的，是编译器自动分配的，这就是所谓的“分配动态内存”

所以当你取用 i 的时候，你是直接随手从盒子里取出i的那张纸条，一看 值是10.
而当你要取用 A 的时候，你从盒子里取出A的那张纸条，然后跑到仓库里，对应的位置（第3个货架，第二个格子）翻出那个ClassA （好大的一个箱子）

这就是我们所谓的“指针”的含义，指针指向“内存地址”的具体意思。

然后我们再看另一个例子
ClassA* A = new ClassA();
		A = new ClassA();

这两句语句造成了我们所谓的“内存泄露”，自己思考一下吧。

有了这个概念，我们再看一下this指针的概念。
this指针，代表的是类自己，我们设计这么一个类

class ClassA
{
public:
	void func1();

	void func2();

	int m_num;

};

void ClassA::func1()
{
	this->func2();
}

void ClassA::setNum(num)
{
	m_num = num;
}

void ClassA::func2()
{
	int curNum = this->m_num;
	printf("%d\n", curNum);
}

所以在我们如下使用方法的时候

void int main(int argc, char const *argv[])
{
	ClassA* A = new ClassA();
	A->setNum(10);
	A->func1();

	ClassA* B = new ClassA();
	B->setNum(20);
	B->func1();
}

func1会调用各自不同的func2，然后调用各自的m_num,

想象一下，我们在仓库里创建了两个ClassA的货柜，然后每个货柜里都有 func1，func2和 m_num三个成员，然后他们之间会互相调用，
so，就是这样



